"use strict";

/**
 * Masonry Reactions - Build-time script
 * 
 * Pre-creates GitHub Discussions with comments for each masonry page image.
 * Each comment tracks heart reactions as "likes" for individual photos.
 * 
 * Flow:
 * 1. For each masonry page, find or create a discussion with prefix [masonry-reactions]
 * 2. Create a comment for each image (if not already present)
 * 3. Lock the discussion (users can still react, but can't add new comments)
 * 4. Fetch heart reaction counts and embed them in the page data
 */

const https = require("https");

const GITHUB_GRAPHQL_API = "https://api.github.com/graphql";
const REACTIONS_PREFIX = "[masonry-reactions] ";

/* ==================== GitHub GraphQL API ==================== */

function graphqlRequest(pat, query, variables = {}) {
  return new Promise((resolve, reject) => {
    const body = JSON.stringify({ query, variables });
    const url = new URL(GITHUB_GRAPHQL_API);
    const options = {
      hostname: url.hostname,
      path: url.pathname,
      method: "POST",
      headers: {
        Authorization: `Bearer ${pat}`,
        "Content-Type": "application/json",
        "User-Agent": "hexo-masonry-reactions",
        "Content-Length": Buffer.byteLength(body),
      },
    };

    const req = https.request(options, (res) => {
      let data = "";
      res.on("data", (chunk) => (data += chunk));
      res.on("end", () => {
        try {
          resolve(JSON.parse(data));
        } catch (e) {
          reject(new Error(`Failed to parse GitHub API response: ${e.message}`));
        }
      });
    });
    req.on("error", reject);
    req.write(body);
    req.end();
  });
}

/* ==================== Discussion Management ==================== */

/**
 * Search for an existing reactions discussion by exact title match
 */
async function findReactionsDiscussion(pat, repo, pagePath) {
  const term = `${REACTIONS_PREFIX}${pagePath}`;
  const searchQuery = `"${term}" in:title repo:${repo} is:discussion`;

  const query = `
    query($searchQuery: String!) {
      search(query: $searchQuery, type: DISCUSSION, first: 5) {
        discussionCount
        nodes {
          ... on Discussion {
            id
            number
            title
            locked
            comments(first: 100) {
              totalCount
              nodes {
                id
                body
                reactions(content: HEART, first: 0) {
                  totalCount
                }
              }
            }
          }
        }
      }
    }
  `;

  const result = await graphqlRequest(pat, query, { searchQuery });

  if (result.errors) {
    throw new Error(`GitHub search error: ${JSON.stringify(result.errors)}`);
  }

  if (result.data?.search?.nodes) {
    for (const node of result.data.search.nodes) {
      if (node.title === term) {
        return node;
      }
    }
  }

  return null;
}

/**
 * Create a new reactions discussion
 */
async function createReactionsDiscussion(pat, repositoryId, categoryId, pagePath) {
  const term = `${REACTIONS_PREFIX}${pagePath}`;

  const query = `
    mutation($input: CreateDiscussionInput!) {
      createDiscussion(input: $input) {
        discussion {
          id
          number
          title
        }
      }
    }
  `;

  const result = await graphqlRequest(pat, query, {
    input: {
      repositoryId,
      categoryId,
      title: term,
      body: `This discussion is auto-generated for tracking photo reactions on the masonry page: \`${pagePath}\`\n\n‚ö†Ô∏è Please do not delete or modify this discussion. Comments here are mapped to individual photos.\n\n---\n*Generated by hexo-masonry-reactions*`,
    },
  });

  if (result.errors) {
    throw new Error(`Failed to create discussion: ${JSON.stringify(result.errors)}`);
  }

  return result.data?.createDiscussion?.discussion;
}

/**
 * Add a comment for a specific image
 */
async function addImageComment(pat, discussionId, imageId, imageTitle) {
  const query = `
    mutation($input: AddDiscussionCommentInput!) {
      addDiscussionComment(input: $input) {
        comment {
          id
        }
      }
    }
  `;

  const body = `<!-- masonry-image-id: ${imageId} -->\nüì∑ **${imageTitle || imageId}**`;

  const result = await graphqlRequest(pat, query, {
    input: { discussionId, body },
  });

  if (result.errors) {
    throw new Error(`Failed to add comment: ${JSON.stringify(result.errors)}`);
  }

  return result.data?.addDiscussionComment?.comment;
}

/**
 * Lock a discussion to prevent new comments (reactions still allowed)
 */
async function lockDiscussion(pat, lockableId) {
  const query = `
    mutation($input: LockLockableInput!) {
      lockLockable(input: $input) {
        lockedRecord { locked }
      }
    }
  `;

  await graphqlRequest(pat, query, {
    input: { lockableId, lockReason: "OFF_TOPIC" },
  });
}

/**
 * Unlock a discussion (needed to add new comments)
 */
async function unlockDiscussion(pat, lockableId) {
  const query = `
    mutation($input: UnlockLockableInput!) {
      unlockLockable(input: $input) {
        unlockedRecord { locked }
      }
    }
  `;

  await graphqlRequest(pat, query, {
    input: { lockableId },
  });
}

/**
 * Parse the masonry-image-id from a comment body
 */
function parseImageId(commentBody) {
  if (!commentBody) return null;
  const match = commentBody.match(/<!-- masonry-image-id: (.+?) -->/);
  return match ? match[1].trim() : null;
}

/**
 * Process reactions for a single masonry page.
 * Returns { discussionNumber, imageReactions: { [imageId]: { commentId, heartCount } } }
 */
async function processPageReactions(pat, repo, repositoryId, categoryId, pagePath, images, log) {
  try {
    // 1. Find or create discussion
    let discussion = await findReactionsDiscussion(pat, repo, pagePath);

    if (!discussion) {
      log.info(`[masonry-reactions] Creating discussion for: ${pagePath}`);
      discussion = await createReactionsDiscussion(pat, repositoryId, categoryId, pagePath);
      if (!discussion) {
        log.error(`[masonry-reactions] Failed to create discussion for: ${pagePath}`);
        return null;
      }
      discussion.comments = { totalCount: 0, nodes: [] };
      discussion.locked = false;
    }

    // 2. Parse existing comments
    const existingComments = discussion.comments?.nodes || [];
    const existingImageIds = new Set();
    const imageCommentMap = {};

    for (const comment of existingComments) {
      const imageId = parseImageId(comment.body);
      if (imageId) {
        existingImageIds.add(imageId);
        imageCommentMap[imageId] = {
          commentId: comment.id,
          heartCount: comment.reactions?.totalCount || 0,
        };
      }
    }

    // 3. Find images that need new comments
    const newImages = images.filter((img) => !existingImageIds.has(img.image));

    if (newImages.length > 0) {
      // Unlock if locked
      if (discussion.locked) {
        log.info(`[masonry-reactions] Unlocking discussion to add ${newImages.length} new comments`);
        await unlockDiscussion(pat, discussion.id);
      }

      for (const img of newImages) {
        log.info(`[masonry-reactions] Adding comment for: ${img.image}`);
        const comment = await addImageComment(pat, discussion.id, img.image, img.title);
        if (comment) {
          imageCommentMap[img.image] = {
            commentId: comment.id,
            heartCount: 0,
          };
        }
        // Small delay to avoid hitting rate limits
        await new Promise((r) => setTimeout(r, 200));
      }

      // Re-lock
      log.info(`[masonry-reactions] Locking discussion`);
      await lockDiscussion(pat, discussion.id);
    } else if (!discussion.locked) {
      // Lock if not already locked and no new comments needed
      log.info(`[masonry-reactions] Locking discussion (no new images)`);
      await lockDiscussion(pat, discussion.id);
    }

    return {
      discussionNumber: discussion.number,
      imageReactions: imageCommentMap,
    };
  } catch (err) {
    log.error(`[masonry-reactions] Error processing ${pagePath}: ${err.message}`);
    return null;
  }
}

/* ==================== Hexo Integration ==================== */

hexo.extend.filter.register("before_generate", async function () {
  const giscusConfig = hexo.theme.config?.comment?.config?.giscus;
  if (!giscusConfig) return;

  const pat = giscusConfig.author_pat;
  const repo = giscusConfig.repo;
  const repositoryId = giscusConfig.repo_id;
  const categoryId = giscusConfig.category_id;
  const commentEnabled = hexo.theme.config?.comment?.enable;

  if (!pat || !repo || !repositoryId || !categoryId) {
    hexo.log.info("[masonry-reactions] Skipping: missing giscus config (repo, repo_id, category_id, or author_pat)");
    return;
  }

  if (!commentEnabled) {
    hexo.log.info("[masonry-reactions] Skipping: comments are disabled");
    return;
  }

  // Load masonry data
  const data = hexo.locals.get("data");
  const masonryData = data?.masonry;
  if (!masonryData) {
    hexo.log.info("[masonry-reactions] Skipping: no masonry data found");
    return;
  }

  const categories = masonryData.filter((item) => item.links_category);
  const allReactions = {};

  hexo.log.info("[masonry-reactions] Processing masonry page reactions...");

  for (const category of categories) {
    for (const item of category.list || []) {
      if (!item.images || item.images.length === 0) continue;

      const pageTitle = item["page-title"] || item.name;
      // Build the page path as giscus pathname mapping would
      const pagePath = `masonry/${pageTitle}/`;

      const result = await processPageReactions(
        pat, repo, repositoryId, categoryId, pagePath, item.images, hexo.log
      );

      if (result) {
        allReactions[pagePath] = result;
        hexo.log.info(
          `[masonry-reactions] ${pagePath}: ${Object.keys(result.imageReactions).length} images tracked`
        );
      }
    }
  }

  // Store for the masonry generator to pick up
  hexo._masonryReactions = allReactions;
  hexo.log.info(`[masonry-reactions] Done. ${Object.keys(allReactions).length} pages processed.`);
});
